name: CLI CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

env:
  RUST_VERSION: "1.89"
  BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
  BORINGCACHE_BOOTSTRAP_VERSION: "v1.0.3"

jobs:
  test-boringcache:
    name: Test CLI (BoringCache)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        run: [1, 2, 3]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust (BoringCache)
        id: boringcache-rust
        continue-on-error: true
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ github.repository }}
          rust-version: ${{ env.RUST_VERSION }}
          sccache: "true"
          sccache-mode: "proxy"

      - name: Setup Rust (Fallback)
        if: steps.boringcache-rust.outcome == 'failure'
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ github.repository }}
          rust-version: ${{ env.RUST_VERSION }}
          sccache: "true"
          sccache-mode: "proxy"

      - name: Cache cargo (Fallback)
        if: steps.boringcache-rust.outcome == 'failure'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install Rust components
        run: rustup component add clippy rustfmt

      - name: Build and test with timing
        run: |
          START_TIME=$(date +%s%N)
          cargo build
          cargo test
          cargo clippy -- -D warnings
          END_TIME=$(date +%s%N)
          DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "BoringCache build+test - Run ${{ matrix.run }}: ${DURATION}ms"
          mkdir -p benchmark-results
          echo "${DURATION}" > benchmark-results/boringcache-run${{ matrix.run }}.txt

      - name: Check formatting
        run: cargo fmt -- --check

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: boringcache-results-${{ matrix.run }}
          path: benchmark-results/

  test-actions-cache:
    name: Test CLI (Actions Cache)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        run: [1, 2, 3]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ github.repository }}
          rust-version: ${{ env.RUST_VERSION }}
          sccache: "true"
          sccache-mode: "proxy"

      - name: Install Rust components
        run: rustup component add clippy rustfmt

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build and test with timing
        run: |
          START_TIME=$(date +%s%N)
          cargo build
          cargo test
          cargo clippy -- -D warnings
          END_TIME=$(date +%s%N)
          DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "Actions cache build+test - Run ${{ matrix.run }}: ${DURATION}ms"
          mkdir -p benchmark-results
          echo "${DURATION}" > benchmark-results/actions-cache-run${{ matrix.run }}.txt

      - name: Check formatting
        run: cargo fmt -- --check

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: actions-cache-results-${{ matrix.run }}
          path: benchmark-results/

  docker:
    name: Test Docker
    runs-on: ubuntu-latest
    strategy:
      matrix:
        run: [1, 2, 3]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build and test with timing
        run: |
          docker run --rm \
            -v "$PWD:/workspace" \
            -w /workspace \
            -e CARGO_TARGET_DIR=/workspace/target \
            -e BORINGCACHE_API_TOKEN=${{ secrets.BORINGCACHE_API_TOKEN }} \
            rust:${{ env.RUST_VERSION }}-bookworm \
            sh -c '
              set -e

              # Install a stable boringcache bootstrap binary (optional)
              BC_CACHE_ENABLED=0
              BOOTSTRAP_URL="https://github.com/boringcache/cli/releases/download/${{ env.BORINGCACHE_BOOTSTRAP_VERSION }}/boringcache-debian-bookworm-amd64"
              if curl -fsSL "$BOOTSTRAP_URL" -o /tmp/boringcache-bootstrap; then
                chmod +x /tmp/boringcache-bootstrap
                mv /tmp/boringcache-bootstrap /usr/local/bin/boringcache
                if boringcache --version >/dev/null 2>&1; then
                  BC_CACHE_ENABLED=1
                  # Restore target cache
                  boringcache restore ${{ github.repository }} \
                    "docker-target-cargo-registry:/root/.cargo/registry,docker-target-cargo-git:/root/.cargo/git,docker-target-target:/workspace/target" \
                    || echo "Cache restore skipped"
                else
                  echo "Downloaded bootstrap boringcache binary is invalid - skipping cache restore/save"
                fi
              else
                echo "Bootstrap boringcache download failed from $BOOTSTRAP_URL - continuing without cache"
              fi

              # Build with timing
              START_TIME=$(date +%s%N)
              cargo build
              cargo test
              END_TIME=$(date +%s%N)
              DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
              echo "Docker target cache - Run ${{ matrix.run }}: ${DURATION}ms"
              mkdir -p benchmark-results
              echo "${DURATION}" > benchmark-results/docker-target-run${{ matrix.run }}.txt

              # Save target cache
              if [ "$BC_CACHE_ENABLED" = "1" ]; then
                boringcache save ${{ github.repository }} \
                  "docker-target-cargo-registry:/root/.cargo/registry,docker-target-cargo-git:/root/.cargo/git,docker-target-target:/workspace/target" \
                  || echo "Cache save skipped"
              fi
            '

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: docker-target-results-${{ matrix.run }}
          path: benchmark-results/

  benchmark-summary:
    name: Cache Benchmark Summary
    runs-on: ubuntu-latest
    needs:
      - test-boringcache
      - test-actions-cache
      - docker
    if: always()
    steps:
      - name: Download all results
        uses: actions/download-artifact@v4
        with:
          pattern: "*-results-*"
          merge-multiple: true

      - name: Generate summary
        run: |
          echo "# Rust Build Cache Benchmark Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Native Runner: actions/cache vs boringcache" >> $GITHUB_STEP_SUMMARY
          echo "| Run | actions/cache | boringcache | Improvement |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|---------------|-------------|-------------|" >> $GITHUB_STEP_SUMMARY
          for run in 1 2 3; do
            if [[ -f "actions-cache-run${run}.txt" && -f "boringcache-run${run}.txt" ]]; then
              a=$(cat "actions-cache-run${run}.txt"); b=$(cat "boringcache-run${run}.txt")
              if [[ $b -gt 0 ]]; then imp=$(echo "scale=1; $a / $b" | bc -l); else imp="N/A"; fi
              echo "| $run | ${a}ms | ${b}ms | ${imp}x faster |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| $run | Missing | Missing | N/A |" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Docker" >> $GITHUB_STEP_SUMMARY
          echo "| Run | Time |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|------|" >> $GITHUB_STEP_SUMMARY
          for run in 1 2 3; do
            if [[ -f "docker-target-run${run}.txt" ]]; then
              t=$(cat "docker-target-run${run}.txt")
              echo "| $run | ${t}ms |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| $run | Missing |" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Averages" >> $GITHUB_STEP_SUMMARY
          echo "### Native Runner" >> $GITHUB_STEP_SUMMARY
          if [[ -f actions-cache-run1.txt && -f actions-cache-run2.txt && -f actions-cache-run3.txt && -f boringcache-run1.txt && -f boringcache-run2.txt && -f boringcache-run3.txt ]]; then
            aa=$(( ($(cat actions-cache-run1.txt)+$(cat actions-cache-run2.txt)+$(cat actions-cache-run3.txt))/3 ))
            bb=$(( ($(cat boringcache-run1.txt)+$(cat boringcache-run2.txt)+$(cat boringcache-run3.txt))/3 ))
            if [[ $bb -gt 0 ]]; then imp=$(echo "scale=1; $aa / $bb" | bc -l); else imp="N/A"; fi
            echo "- **actions/cache**: ${aa}ms" >> $GITHUB_STEP_SUMMARY
            echo "- **boringcache**: ${bb}ms" >> $GITHUB_STEP_SUMMARY
            echo "- **Improvement**: ${imp}x faster with boringcache" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Docker" >> $GITHUB_STEP_SUMMARY
          if [[ -f docker-target-run1.txt && -f docker-target-run2.txt && -f docker-target-run3.txt ]]; then
            tt=$(( ($(cat docker-target-run1.txt)+$(cat docker-target-run2.txt)+$(cat docker-target-run3.txt))/3 ))
            echo "- **Average**: ${tt}ms" >> $GITHUB_STEP_SUMMARY
          fi

  build:
    name: Build CLI - ${{ matrix.name }}
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          # Ubuntu builds (GitHub-hosted native)
          - runner: ubuntu-22.04
            name: ubuntu-22.04-amd64
            target: x86_64-unknown-linux-gnu
            binary_name: boringcache-ubuntu-22.04-amd64
            use_docker: false
          
          - runner: ubuntu-24.04
            name: ubuntu-24.04-amd64
            target: x86_64-unknown-linux-gnu
            binary_name: boringcache-ubuntu-24.04-amd64
            use_docker: false

          # Ubuntu 25.04 build (Docker on GitHub-hosted)
          - runner: ubuntu-latest
            name: ubuntu-25.04-amd64
            container: ubuntu:25.04
            target: x86_64-unknown-linux-gnu
            binary_name: boringcache-ubuntu-25.04-amd64
            use_docker: true

          # Debian build sample (Docker on GitHub-hosted)
          - runner: ubuntu-latest
            name: debian-bookworm-amd64
            container: rust:1.89-bookworm
            target: x86_64-unknown-linux-gnu
            binary_name: boringcache-debian-bookworm-amd64
            use_docker: true
          
          # Alpine build sample (Docker on GitHub-hosted)
          - runner: ubuntu-latest
            name: alpine-amd64
            container: rust:1.89-alpine
            target: x86_64-unknown-linux-musl
            binary_name: boringcache-alpine-amd64
            use_docker: true
            musl: true
          
          # macOS builds (GitHub-hosted native)
          - runner: macos-15
            name: macos-15-arm64
            target: aarch64-apple-darwin
            binary_name: boringcache-macos-15-arm64
            use_docker: false
          
          # Windows builds (GitHub-hosted native)
          - runner: windows-2022
            name: windows-2022-amd64
            target: x86_64-pc-windows-msvc
            binary_name: boringcache-windows-2022-amd64.exe
            use_docker: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Docker builds for Debian/Alpine
      - name: Build in Docker container
        if: matrix.use_docker == true
        run: |
          docker run --rm \
            -v "$PWD:/workspace" \
            -w /workspace \
            -e CARGO_TARGET_DIR=/workspace/target \
            -e BORINGCACHE_API_TOKEN=${{ secrets.BORINGCACHE_API_TOKEN }} \
            ${{ matrix.container }} \
            sh -c '
              set -e

              # Install build dependencies based on container type
              if [ -f /etc/alpine-release ]; then
                # Alpine packages (minimal - rustls is pure Rust, no OpenSSL needed)
                apk add --no-cache build-base musl-dev curl
              elif [ -f /etc/debian_version ]; then
                # Debian/Ubuntu packages
                apt-get update
                apt-get install -y build-essential pkg-config libssl-dev curl
                # Install Rust if not present (for bare Ubuntu images)
                if ! command -v rustup >/dev/null 2>&1; then
                  curl --proto "=https" --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain ${{ env.RUST_VERSION }}
                  export PATH="/usr/local/cargo/bin:$HOME/.cargo/bin:$PATH"
                fi
              fi

              # Install a known stable boringcache CLI (optional - build continues if unavailable)
              BC_CACHE_ENABLED=0
              BOOTSTRAP_URL="https://github.com/boringcache/cli/releases/download/${{ env.BORINGCACHE_BOOTSTRAP_VERSION }}/${{ matrix.binary_name }}"
              if curl -fsSL "$BOOTSTRAP_URL" -o /tmp/boringcache-bootstrap; then
                chmod +x /tmp/boringcache-bootstrap
                mv /tmp/boringcache-bootstrap /usr/local/bin/boringcache
                if boringcache --version >/dev/null 2>&1; then
                  BC_CACHE_ENABLED=1
                  # Restore Cargo cache before build
                  boringcache restore ${{ github.repository }} \
                    "cargo-registry-${{ matrix.name }}:/root/.cargo/registry,cargo-git-${{ matrix.name }}:/root/.cargo/git,cargo-target-${{ matrix.name }}:/workspace/target" \
                    || echo "Cache restore skipped (cache miss or error)"
                else
                  echo "Downloaded bootstrap boringcache binary is invalid - skipping cache restore/save"
                fi
              else
                echo "Bootstrap boringcache download failed from $BOOTSTRAP_URL - continuing without cache"
              fi

              # Add target
              rustup target add ${{ matrix.target }}

              # Build with appropriate flags
              if [ "${{ matrix.musl }}" = "true" ]; then
                RUSTFLAGS="-C target-feature=+crt-static" cargo build --release --target ${{ matrix.target }}
              else
                cargo build --release --target ${{ matrix.target }}
              fi

              # Copy binary before saving cache (so target cache excludes final binary)
              cp target/${{ matrix.target }}/release/boringcache /workspace/${{ matrix.binary_name }}
              chmod +x /workspace/${{ matrix.binary_name }}

              # Save Cargo cache after build (if stable bootstrap CLI is available)
              if [ "$BC_CACHE_ENABLED" = "1" ]; then
                boringcache save ${{ github.repository }} \
                  "cargo-registry-${{ matrix.name }}:/root/.cargo/registry,cargo-git-${{ matrix.name }}:/root/.cargo/git,cargo-target-${{ matrix.name }}:/workspace/target" \
                  || echo "Cache save skipped (error)"
              fi
            '

      # Native builds for Ubuntu/macOS/Windows
      - name: Setup Rust (Native builds)
        id: boringcache-rust-native
        if: matrix.use_docker != true
        continue-on-error: true
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ github.repository }}
          rust-version: ${{ env.RUST_VERSION }}
          sccache: "true"
          sccache-mode: "proxy"

      - name: Setup Rust (Native Fallback)
        if: matrix.use_docker != true && steps.boringcache-rust-native.outcome == 'failure'
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ github.repository }}
          rust-version: ${{ env.RUST_VERSION }}
          sccache: "true"
          sccache-mode: "proxy"

      - name: Cache cargo (Native Fallback)
        if: matrix.use_docker != true && steps.boringcache-rust-native.outcome == 'failure'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ matrix.name }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.name }}-cargo-

      - name: Install Rust target (Native builds)
        if: matrix.use_docker != true
        run: rustup target add ${{ matrix.target }}

      - name: Build CLI (Native builds)
        if: matrix.use_docker != true
        run: |
          cargo build --release --target ${{ matrix.target }}

      - name: Prepare binary (Native builds)
        if: matrix.use_docker != true
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            cp target/${{ matrix.target }}/release/boringcache.exe ${{ matrix.binary_name }}
          else
            cp target/${{ matrix.target }}/release/boringcache ${{ matrix.binary_name }}
            chmod +x ${{ matrix.binary_name }}
          fi
