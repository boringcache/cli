name: CLI CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

env:
  RUST_VERSION: "1.89"
  BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
  SCCACHE_VERSION: "v0.13.0"
  CARGO_INCREMENTAL: "0"

jobs:
  test-boringcache:
    name: Test CLI (BoringCache)
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1
      matrix:
        run: [1, 2, 3]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust (BoringCache)
        id: boringcache-rust
        continue-on-error: true
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ github.repository }}
          rust-version: ${{ env.RUST_VERSION }}
          cache-tag: "rust-${{ env.RUST_VERSION }}-ci-test"
          sccache: "true"
          sccache-mode: "proxy"
          cache-target: "false"

      - name: Setup Rust (Fallback)
        if: steps.boringcache-rust.outcome == 'failure'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}

      - name: Install Rust components
        run: rustup component add clippy rustfmt

      - name: Build and test with timing
        run: |
          START_TIME=$(date +%s%N)
          cargo build --locked
          cargo test --locked
          cargo clippy --locked -- -D warnings
          END_TIME=$(date +%s%N)
          DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "BoringCache build+test - Run ${{ matrix.run }}: ${DURATION}ms"
          mkdir -p benchmark-results
          echo "${DURATION}" > benchmark-results/boringcache-run${{ matrix.run }}.txt

      - name: Check formatting
        run: cargo fmt -- --check

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: boringcache-results-${{ matrix.run }}
          path: benchmark-results/

  docker:
    name: Test Docker
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1
      matrix:
        run: [1, 2, 3]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup BoringCache CLI
        continue-on-error: true
        uses: boringcache/setup-boringcache@v1
        with:
          token: ${{ secrets.BORINGCACHE_API_TOKEN }}
          platform: linux-amd64

      - name: Build and test with timing
        run: |
          BC_MOUNT=""
          if command -v boringcache >/dev/null 2>&1; then
            BC_MOUNT="-v $(which boringcache):/usr/local/bin/boringcache:ro"
          fi
          docker run --rm \
            -v "$PWD:/workspace" \
            $BC_MOUNT \
            -w /workspace \
            -e CARGO_TARGET_DIR=/workspace/target \
            -e BORINGCACHE_API_TOKEN=${{ secrets.BORINGCACHE_API_TOKEN }} \
            rust:${{ env.RUST_VERSION }}-bookworm \
            sh -c '
              set -e

              # Install sccache + start proxy for compilation caching
              if boringcache --version >/dev/null 2>&1; then
                SCCACHE_URL="https://github.com/mozilla/sccache/releases/download/${{ env.SCCACHE_VERSION }}/sccache-${{ env.SCCACHE_VERSION }}-x86_64-unknown-linux-musl.tar.gz"
                if curl -fsSL "$SCCACHE_URL" | tar xz -C /tmp; then
                  mv "/tmp/sccache-${{ env.SCCACHE_VERSION }}-x86_64-unknown-linux-musl/sccache" /usr/local/bin/sccache
                  chmod +x /usr/local/bin/sccache
                  sccache --version

                  SCCACHE_PORT=4227
                  # Keep a stable root tag in normal CI to preserve key->digest mappings across runs.
                  boringcache cache-registry ${{ github.repository }} "rust-${{ env.RUST_VERSION }}-sccache-docker-test" \
                    --host 127.0.0.1 --port "$SCCACHE_PORT" --no-platform --no-git &
                  PROXY_PID=$!
                  for _ in $(seq 1 30); do
                    curl -fsS --max-time 1 "http://127.0.0.1:${SCCACHE_PORT}/v2/" >/dev/null 2>&1 && break
                    sleep 0.5
                  done
                  export SCCACHE_WEBDAV_ENDPOINT="http://127.0.0.1:${SCCACHE_PORT}/"
                  export RUSTC_WRAPPER=sccache
                  echo "sccache proxy configured: endpoint=$SCCACHE_WEBDAV_ENDPOINT"
                  sccache --start-server || true
                fi
              fi

              # Build with timing
              START_TIME=$(date +%s%N)
              cargo build --locked
              cargo test --locked
              END_TIME=$(date +%s%N)
              DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
              echo "Docker target cache - Run ${{ matrix.run }}: ${DURATION}ms"
              mkdir -p benchmark-results
              echo "${DURATION}" > benchmark-results/docker-target-run${{ matrix.run }}.txt

              echo "=== sccache stats ==="
              sccache --show-stats || true
            '

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: docker-target-results-${{ matrix.run }}
          path: benchmark-results/

  benchmark-summary:
    name: Cache Benchmark Summary
    runs-on: ubuntu-latest
    needs:
      - test-boringcache
      - docker
    if: always()
    steps:
      - name: Download all results
        uses: actions/download-artifact@v4
        with:
          pattern: "*-results-*"
          merge-multiple: true

      - name: Generate summary
        run: |
          echo "# Rust Build Cache Benchmark Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Native Runner (boringcache + sccache proxy)" >> $GITHUB_STEP_SUMMARY
          echo "| Run | Time |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|------|" >> $GITHUB_STEP_SUMMARY
          for run in 1 2 3; do
            if [[ -f "boringcache-run${run}.txt" ]]; then
              b=$(cat "boringcache-run${run}.txt")
              echo "| $run | ${b}ms |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| $run | Missing |" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Docker (boringcache + sccache proxy)" >> $GITHUB_STEP_SUMMARY
          echo "| Run | Time |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|------|" >> $GITHUB_STEP_SUMMARY
          for run in 1 2 3; do
            if [[ -f "docker-target-run${run}.txt" ]]; then
              t=$(cat "docker-target-run${run}.txt")
              echo "| $run | ${t}ms |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| $run | Missing |" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Averages" >> $GITHUB_STEP_SUMMARY
          echo "### Native Runner" >> $GITHUB_STEP_SUMMARY
          if [[ -f boringcache-run1.txt && -f boringcache-run2.txt && -f boringcache-run3.txt ]]; then
            bb=$(( ($(cat boringcache-run1.txt)+$(cat boringcache-run2.txt)+$(cat boringcache-run3.txt))/3 ))
            echo "- **Average**: ${bb}ms" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Docker" >> $GITHUB_STEP_SUMMARY
          if [[ -f docker-target-run1.txt && -f docker-target-run2.txt && -f docker-target-run3.txt ]]; then
            tt=$(( ($(cat docker-target-run1.txt)+$(cat docker-target-run2.txt)+$(cat docker-target-run3.txt))/3 ))
            echo "- **Average**: ${tt}ms" >> $GITHUB_STEP_SUMMARY
          fi

  build:
    name: Build CLI - ${{ matrix.name }}
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          # Ubuntu builds (GitHub-hosted native)
          - runner: ubuntu-22.04
            name: ubuntu-22.04-amd64
            target: x86_64-unknown-linux-gnu
            binary_name: boringcache-ubuntu-22.04-amd64
            use_docker: false
          
          - runner: ubuntu-24.04
            name: ubuntu-24.04-amd64
            target: x86_64-unknown-linux-gnu
            binary_name: boringcache-ubuntu-24.04-amd64
            use_docker: false

          # Ubuntu 25.04 build (Docker on GitHub-hosted)
          - runner: ubuntu-latest
            name: ubuntu-25.04-amd64
            container: ubuntu:25.04
            target: x86_64-unknown-linux-gnu
            binary_name: boringcache-ubuntu-25.04-amd64
            use_docker: true

          # Debian build sample (Docker on GitHub-hosted)
          - runner: ubuntu-latest
            name: debian-bookworm-amd64
            container: rust:1.89-bookworm
            target: x86_64-unknown-linux-gnu
            binary_name: boringcache-debian-bookworm-amd64
            use_docker: true
          
          # Alpine build sample (Docker on GitHub-hosted)
          - runner: ubuntu-latest
            name: alpine-amd64
            container: rust:1.89-alpine
            target: x86_64-unknown-linux-musl
            binary_name: boringcache-alpine-amd64
            use_docker: true
            musl: true
          
          # macOS builds (GitHub-hosted native)
          - runner: macos-15
            name: macos-15-arm64
            target: aarch64-apple-darwin
            binary_name: boringcache-macos-15-arm64
            use_docker: false
          
          # Windows builds (GitHub-hosted native)
          - runner: windows-2022
            name: windows-2022-amd64
            target: x86_64-pc-windows-msvc
            binary_name: boringcache-windows-2022-amd64.exe
            use_docker: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup BoringCache CLI
        if: matrix.use_docker == true
        continue-on-error: true
        uses: boringcache/setup-boringcache@v1
        with:
          token: ${{ secrets.BORINGCACHE_API_TOKEN }}
          platform: ${{ matrix.musl && 'alpine-amd64' || 'linux-amd64' }}

      # Docker builds for Debian/Alpine
      - name: Build in Docker container
        if: matrix.use_docker == true
        run: |
          BC_MOUNT=""
          if command -v boringcache >/dev/null 2>&1; then
            BC_MOUNT="-v $(which boringcache):/usr/local/bin/boringcache:ro"
          fi
          docker run --rm \
            -v "$PWD:/workspace" \
            $BC_MOUNT \
            -w /workspace \
            -e CARGO_TARGET_DIR=/workspace/target \
            -e BORINGCACHE_API_TOKEN=${{ secrets.BORINGCACHE_API_TOKEN }} \
            ${{ matrix.container }} \
            sh -c '
              set -e

              # Install build dependencies based on container type
              if [ -f /etc/alpine-release ]; then
                apk add --no-cache build-base musl-dev curl
              elif [ -f /etc/debian_version ]; then
                apt-get update
                apt-get install -y build-essential pkg-config libssl-dev curl
                if ! command -v rustup >/dev/null 2>&1; then
                  curl --proto "=https" --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain ${{ env.RUST_VERSION }}
                  export PATH="/usr/local/cargo/bin:$HOME/.cargo/bin:$PATH"
                fi
              fi

              # Install sccache + start proxy for compilation caching
              if boringcache --version >/dev/null 2>&1; then
                SCCACHE_URL="https://github.com/mozilla/sccache/releases/download/${{ env.SCCACHE_VERSION }}/sccache-${{ env.SCCACHE_VERSION }}-x86_64-unknown-linux-musl.tar.gz"
                if curl -fsSL "$SCCACHE_URL" | tar xz -C /tmp; then
                  mv "/tmp/sccache-${{ env.SCCACHE_VERSION }}-x86_64-unknown-linux-musl/sccache" /usr/local/bin/sccache
                  chmod +x /usr/local/bin/sccache
                  sccache --version

                  SCCACHE_PORT=4227
                  boringcache cache-registry ${{ github.repository }} "rust-${{ env.RUST_VERSION }}-sccache-${{ matrix.name }}" \
                    --host 127.0.0.1 --port "$SCCACHE_PORT" --no-platform --no-git &
                  PROXY_PID=$!
                  for _ in $(seq 1 30); do
                    curl -fsS --max-time 1 "http://127.0.0.1:${SCCACHE_PORT}/v2/" >/dev/null 2>&1 && break
                    sleep 0.5
                  done
                  export SCCACHE_WEBDAV_ENDPOINT="http://127.0.0.1:${SCCACHE_PORT}/"
                  export RUSTC_WRAPPER=sccache
                  echo "sccache proxy configured: endpoint=$SCCACHE_WEBDAV_ENDPOINT"
                  sccache --start-server || true
                fi
              fi

              # Add target
              rustup target add ${{ matrix.target }}

              # Build with appropriate flags
              if [ "${{ matrix.musl }}" = "true" ]; then
                RUSTFLAGS="-C target-feature=+crt-static" cargo build --locked --release --target ${{ matrix.target }}
              else
                cargo build --locked --release --target ${{ matrix.target }}
              fi

              # Copy binary
              cp target/${{ matrix.target }}/release/boringcache /workspace/${{ matrix.binary_name }}
              chmod +x /workspace/${{ matrix.binary_name }}

              echo "=== sccache stats ==="
              sccache --show-stats || true
            '

      # Native builds for Ubuntu/macOS/Windows
      - name: Setup Rust (Native builds)
        id: boringcache-rust-native
        if: matrix.use_docker != true
        continue-on-error: true
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ github.repository }}
          rust-version: ${{ env.RUST_VERSION }}
          cache-tag: "rust-${{ env.RUST_VERSION }}-ci-build-${{ matrix.name }}"
          sccache: "true"
          sccache-mode: "proxy"
          cache-target: "false"

      - name: Setup Rust (Native Fallback)
        if: matrix.use_docker != true && steps.boringcache-rust-native.outcome == 'failure'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: ${{ matrix.target }}

      - name: Install Rust target (Native builds)
        if: matrix.use_docker != true
        run: rustup target add ${{ matrix.target }}

      - name: Build CLI (Native builds)
        if: matrix.use_docker != true
        run: |
          cargo build --locked --release --target ${{ matrix.target }}

      - name: Prepare binary (Native builds)
        if: matrix.use_docker != true
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            cp target/${{ matrix.target }}/release/boringcache.exe ${{ matrix.binary_name }}
          else
            cp target/${{ matrix.target }}/release/boringcache ${{ matrix.binary_name }}
            chmod +x ${{ matrix.binary_name }}
          fi
