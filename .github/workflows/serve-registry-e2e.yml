name: Serve Registry E2E

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

jobs:
  serve-registry-e2e:
    name: BuildKit Registry E2E
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
      BORINGCACHE_API_URL: "https://api.boringcache.com/v1"
      WORKSPACE: "boringcache/cli"
      CACHE_TAG_PREFIX: "boringcache-cli"
      REGISTRY_ROOT_TAG_PREFIX: "boringcache-cli-registry"
      PORT: "5000"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ env.WORKSPACE }}
          rust-version: "1.89"
          sccache: "true"
          sccache-mode: "proxy"

      - name: Validate configuration
        run: |
          set -euo pipefail
          if [[ -z "${BORINGCACHE_API_TOKEN:-}" ]]; then
            echo "BORINGCACHE_API_TOKEN secret is required"
            exit 1
          fi
          if [[ -z "${WORKSPACE:-}" ]]; then
            echo "WORKSPACE is not set"
            exit 1
          fi

      - name: Build CLI
        run: cargo build --bin boringcache

      - name: Run serve edge-case unit tests
        run: |
          set -euo pipefail
          cargo test --lib serve::state::tests::find_by_digest_prefers_non_empty_finalized_session
          cargo test --lib serve::handlers::tests::put_upload_allows_local_reuse_when_finalize_payload_is_empty

      - name: Validate workspace access
        run: ./target/debug/boringcache ls "${WORKSPACE}" --limit 1

      - name: Run docker-registry edge-case e2e matrix
        run: |
          set -euo pipefail

          BUILDER="bc-e2e-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          CACHE_TAG="${CACHE_TAG_PREFIX}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          CACHE_REF="localhost:${PORT}/boringcache-e2e/cache:${CACHE_TAG}"
          CACHE_TAG_ALIAS="${CACHE_TAG}-alias"
          CACHE_REF_ALIAS="localhost:${PORT}/boringcache-e2e/cache:${CACHE_TAG_ALIAS}"
          REGISTRY_ROOT_TAG="${REGISTRY_ROOT_TAG_PREFIX}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          SERVE_PID=""
          declare -a LOG_FILES=()

          cleanup() {
            set +e
            if [[ -n "${SERVE_PID:-}" ]]; then
              kill "${SERVE_PID}" >/dev/null 2>&1 || true
              wait "${SERVE_PID}" >/dev/null 2>&1 || true
            fi
            docker buildx rm --force "${BUILDER}" >/dev/null 2>&1 || true
          }
          trap cleanup EXIT

          start_proxy() {
            local log_file="$1"
            LOG_FILES+=("$log_file")
            ./target/debug/boringcache docker-registry "${WORKSPACE}" "${REGISTRY_ROOT_TAG}" --host 127.0.0.1 --port "${PORT}" --no-platform --no-git > "${log_file}" 2>&1 &
            SERVE_PID=$!

            local ready=0
            for _ in $(seq 1 60); do
              if curl -fsS --max-time 1 "http://127.0.0.1:${PORT}/v2/" >/dev/null 2>&1; then
                ready=1
                break
              fi
              if ! kill -0 "${SERVE_PID}" >/dev/null 2>&1; then
                echo "boringcache docker-registry exited before readiness"
                cat "${log_file}"
                exit 1
              fi
              sleep 0.5
            done

            if [[ "${ready}" != "1" ]]; then
              echo "timed out waiting for docker-registry readiness"
              cat "${log_file}"
              exit 1
            fi
          }

          stop_proxy() {
            if [[ -n "${SERVE_PID:-}" ]]; then
              kill "${SERVE_PID}" >/dev/null 2>&1 || true
              wait "${SERVE_PID}" >/dev/null 2>&1 || true
            fi
            SERVE_PID=""
          }

          run_build() {
            local log_file="$1"
            shift
            LOG_FILES+=("$log_file")
            docker buildx build \
              --builder "${BUILDER}" \
              --progress plain \
              --load \
              --file e2e-context/Dockerfile \
              "$@" \
              e2e-context 2>&1 | tee "${log_file}"
          }

          assert_cached() {
            local log_file="$1"
            if ! grep -q "CACHED" "${log_file}"; then
              echo "expected cached steps in ${log_file}"
              exit 1
            fi
          }

          docker buildx create \
            --name "${BUILDER}" \
            --driver docker-container \
            --driver-opt network=host \
            --use

          docker buildx inspect "${BUILDER}" --bootstrap

          mkdir -p e2e-context
          cat > e2e-context/Dockerfile <<'EOF'
          FROM scratch
          COPY payload.bin /payload.bin
          COPY f01.txt /f01.txt
          COPY f02.txt /f02.txt
          COPY f03.txt /f03.txt
          COPY f04.txt /f04.txt
          COPY f05.txt /f05.txt
          COPY f06.txt /f06.txt
          COPY f07.txt /f07.txt
          COPY f08.txt /f08.txt
          COPY f09.txt /f09.txt
          COPY f10.txt /f10.txt
          COPY f11.txt /f11.txt
          COPY f12.txt /f12.txt
          EOF
          for i in $(seq -w 1 12); do
            printf 'layer-%s\n' "${i}" > "e2e-context/f${i}.txt"
          done
          dd if=/dev/zero of=e2e-context/payload.bin bs=1M count=6 status=none

          # Phase 1: seed + warm + no-cache re-export against one tag.
          start_proxy "serve-initial.log"
          run_build "first-build.log" \
            --cache-from "type=registry,ref=${CACHE_REF}" \
            --cache-to "type=registry,ref=${CACHE_REF},mode=max"
          run_build "second-build.log" \
            --cache-from "type=registry,ref=${CACHE_REF}" \
            --cache-to "type=registry,ref=${CACHE_REF},mode=max"
          assert_cached "second-build.log"
          run_build "third-build-reexport.log" \
            --no-cache \
            --cache-to "type=registry,ref=${CACHE_REF},mode=max"
          stop_proxy

          # Phase 2: restart proxy, verify cache still resolves, then alias tag finalize path.
          start_proxy "serve-restart.log"
          run_build "fourth-build-after-restart.log" \
            --cache-from "type=registry,ref=${CACHE_REF}" \
            --cache-to "type=registry,ref=${CACHE_REF},mode=max"
          assert_cached "fourth-build-after-restart.log"
          run_build "fifth-build-alias-export.log" \
            --cache-from "type=registry,ref=${CACHE_REF}" \
            --cache-to "type=registry,ref=${CACHE_REF_ALIAS},mode=max"
          run_build "sixth-build-alias-warm.log" \
            --cache-from "type=registry,ref=${CACHE_REF_ALIAS}" \
            --cache-to "type=registry,ref=${CACHE_REF_ALIAS},mode=max"
          assert_cached "sixth-build-alias-warm.log"

          # Verify both tags are readable manifests through the registry API.
          for tag in "${CACHE_TAG}" "${CACHE_TAG_ALIAS}"; do
            manifest_file="manifest-${tag}.json"
            LOG_FILES+=("${manifest_file}")
            curl -fsS \
              -H "Accept: application/vnd.oci.image.manifest.v1+json,application/vnd.docker.distribution.manifest.v2+json" \
              "http://127.0.0.1:${PORT}/v2/boringcache-e2e/cache/manifests/${tag}" \
              -o "${manifest_file}"
          done

          # Hard fail on known historical export/finalize signatures.
          declare -a BAD_PATTERNS=(
            'expected sha256:.*got sha256:e3b0'
            'error writing layer blob'
            'broken pipe'
            'Validation failed on cache confirm'
            '422 Unprocessable Entity'
            'unexpected status from PUT request.*400 Bad Request'
          )
          for pattern in "${BAD_PATTERNS[@]}"; do
            if grep -E -n "${pattern}" "${LOG_FILES[@]}" >/tmp/e2e-pattern-hit.log 2>/dev/null; then
              echo "found bad signature pattern: ${pattern}"
              cat /tmp/e2e-pattern-hit.log
              exit 1
            fi
          done

      - name: Upload E2E logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: serve-registry-e2e-logs
          path: |
            serve-initial.log
            serve-restart.log
            first-build.log
            second-build.log
            third-build-reexport.log
            fourth-build-after-restart.log
            fifth-build-alias-export.log
            sixth-build-alias-warm.log
            manifest-*.json

  serve-registry-adapter-e2e:
    name: Adapter Protocol E2E
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
      BORINGCACHE_API_URL: "https://api.boringcache.com/v1"
      WORKSPACE: "boringcache/cli"
      REGISTRY_ROOT_TAG_PREFIX: "boringcache-cli-adapter-registry"
      PORT: "5001"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ env.WORKSPACE }}
          rust-version: "1.89"
          sccache: "true"
          sccache-mode: "proxy"

      - name: Validate configuration
        run: |
          set -euo pipefail
          if [[ -z "${BORINGCACHE_API_TOKEN:-}" ]]; then
            echo "BORINGCACHE_API_TOKEN secret is required"
            exit 1
          fi
          if [[ -z "${WORKSPACE:-}" ]]; then
            echo "WORKSPACE is not set"
            exit 1
          fi

      - name: Build CLI
        run: cargo build --bin boringcache

      - name: Validate workspace access
        run: ./target/debug/boringcache ls "${WORKSPACE}" --limit 1

      - name: Run adapter protocol e2e checks
        run: |
          set -euo pipefail

          mkdir -p adapter-e2e
          REGISTRY_ROOT_TAG="${REGISTRY_ROOT_TAG_PREFIX}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          SERVE_PID=""
          ADAPTER_PROXY_LOG="adapter-e2e/adapter-proxy.log"

          cleanup() {
            set +e
            if [[ -n "${SERVE_PID:-}" ]]; then
              kill "${SERVE_PID}" >/dev/null 2>&1 || true
              wait "${SERVE_PID}" >/dev/null 2>&1 || true
            fi
          }
          trap cleanup EXIT

          start_proxy() {
            ./target/debug/boringcache docker-registry "${WORKSPACE}" "${REGISTRY_ROOT_TAG}" --host 127.0.0.1 --port "${PORT}" --no-platform --no-git > "${ADAPTER_PROXY_LOG}" 2>&1 &
            SERVE_PID=$!

            local ready=0
            for _ in $(seq 1 60); do
              if curl -fsS --max-time 1 "http://127.0.0.1:${PORT}/v2/" >/dev/null 2>&1; then
                ready=1
                break
              fi
              if ! kill -0 "${SERVE_PID}" >/dev/null 2>&1; then
                echo "boringcache docker-registry exited before readiness"
                cat "${ADAPTER_PROXY_LOG}"
                exit 1
              fi
              sleep 0.5
            done

            if [[ "${ready}" != "1" ]]; then
              echo "timed out waiting for docker-registry readiness"
              cat "${ADAPTER_PROXY_LOG}"
              exit 1
            fi
          }

          run_http() {
            local expected_status="$1"
            local output_path="$2"
            shift 2
            local status
            status=$(curl -sS -o "${output_path}" -w "%{http_code}" "$@")
            if [[ "${status}" != "${expected_status}" ]]; then
              echo "unexpected status: expected ${expected_status}, got ${status}"
              echo "curl args: $*"
              if [[ -f "${output_path}" ]]; then
                cat "${output_path}"
              fi
              exit 1
            fi
          }

          assert_file_equals() {
            local expected="$1"
            local actual="$2"
            if ! cmp -s "${expected}" "${actual}"; then
              echo "payload mismatch between ${expected} and ${actual}"
              exit 1
            fi
          }

          start_proxy

          # Bazel HTTP cache adapter
          bazel_key=$(printf 'bazel-%s-%s-%s' "${GITHUB_RUN_ID}" "${GITHUB_RUN_ATTEMPT}" "${GITHUB_SHA}" | sha256sum | awk '{print $1}')
          printf 'bazel-e2e-%s\n' "${bazel_key}" > adapter-e2e/bazel.bin
          run_http "200" adapter-e2e/bazel-cas-put.txt -X PUT --data-binary @adapter-e2e/bazel.bin "http://127.0.0.1:${PORT}/cas/${bazel_key}"
          run_http "200" adapter-e2e/bazel-cas-head.txt -I "http://127.0.0.1:${PORT}/cas/${bazel_key}"
          run_http "200" adapter-e2e/bazel-cas-get.bin "http://127.0.0.1:${PORT}/cas/${bazel_key}"
          assert_file_equals adapter-e2e/bazel.bin adapter-e2e/bazel-cas-get.bin

          run_http "200" adapter-e2e/bazel-ac-put.txt -X PUT --data-binary @adapter-e2e/bazel.bin "http://127.0.0.1:${PORT}/ac/${bazel_key}"
          run_http "200" adapter-e2e/bazel-ac-get.bin "http://127.0.0.1:${PORT}/ac/${bazel_key}"
          assert_file_equals adapter-e2e/bazel.bin adapter-e2e/bazel-ac-get.bin

          # Gradle HTTP cache adapter
          gradle_key="gradle-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${GITHUB_SHA:0:7}"
          printf 'gradle-e2e-%s\n' "${gradle_key}" > adapter-e2e/gradle.bin
          run_http "200" adapter-e2e/gradle-put.txt -X PUT --data-binary @adapter-e2e/gradle.bin "http://127.0.0.1:${PORT}/cache/${gradle_key}"
          run_http "200" adapter-e2e/gradle-head.txt -I "http://127.0.0.1:${PORT}/cache/${gradle_key}"
          run_http "200" adapter-e2e/gradle-get.bin "http://127.0.0.1:${PORT}/cache/${gradle_key}"
          assert_file_equals adapter-e2e/gradle.bin adapter-e2e/gradle-get.bin

          # Turborepo adapter
          turbo_hash=$(printf 'turbo-%s-%s-%s' "${GITHUB_RUN_ID}" "${GITHUB_RUN_ATTEMPT}" "${GITHUB_SHA}" | sha256sum | awk '{print $1}')
          turbo_auth="authorization: Bearer turbo-token-${GITHUB_RUN_ID}"
          printf 'turbo-e2e-%s\n' "${turbo_hash}" > adapter-e2e/turbo.bin

          run_http "200" adapter-e2e/turbo-status.json -H "${turbo_auth}" "http://127.0.0.1:${PORT}/v8/artifacts/status"
          grep -q '"status":"enabled"' adapter-e2e/turbo-status.json

          run_http "202" adapter-e2e/turbo-put.json -X PUT -H "${turbo_auth}" --data-binary @adapter-e2e/turbo.bin "http://127.0.0.1:${PORT}/v8/artifacts/${turbo_hash}"
          grep -q '"urls"' adapter-e2e/turbo-put.json

          run_http "200" adapter-e2e/turbo-head.txt -I -H "${turbo_auth}" "http://127.0.0.1:${PORT}/v8/artifacts/${turbo_hash}"
          run_http "200" adapter-e2e/turbo-get.bin -H "${turbo_auth}" "http://127.0.0.1:${PORT}/v8/artifacts/${turbo_hash}"
          assert_file_equals adapter-e2e/turbo.bin adapter-e2e/turbo-get.bin

          cat > adapter-e2e/turbo-query.json <<EOF
          {"hashes":["${turbo_hash}","deadbeef"]}
          EOF
          run_http "200" adapter-e2e/turbo-query-response.json -X POST -H "${turbo_auth}" -H "content-type: application/json" --data @adapter-e2e/turbo-query.json "http://127.0.0.1:${PORT}/v8/artifacts"
          grep -q "\"${turbo_hash}\"" adapter-e2e/turbo-query-response.json
          grep -q '"size"' adapter-e2e/turbo-query-response.json

          cat > adapter-e2e/turbo-events.json <<EOF
          [{"sessionId":"e2e","source":"REMOTE","event":"HIT","hash":"${turbo_hash}","duration":7}]
          EOF
          run_http "200" adapter-e2e/turbo-events-response.txt -X POST -H "${turbo_auth}" -H "content-type: application/json" --data @adapter-e2e/turbo-events.json "http://127.0.0.1:${PORT}/v8/artifacts/events"

          # sccache adapter
          sccache_key=$(printf 'sccache-%s-%s-%s' "${GITHUB_RUN_ID}" "${GITHUB_RUN_ATTEMPT}" "${GITHUB_SHA}" | sha256sum | awk '{print $1}')
          shard_a="${sccache_key:0:1}"
          shard_b="${sccache_key:1:1}"
          shard_c="${sccache_key:2:1}"
          sccache_prefix="sccache-e2e-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          sccache_path="${sccache_prefix}/${shard_a}/${shard_b}/${shard_c}/${sccache_key}"
          printf 'sccache-e2e-%s\n' "${sccache_key}" > adapter-e2e/sccache.bin

          run_http "201" adapter-e2e/sccache-mkcol.txt -X MKCOL "http://127.0.0.1:${PORT}/${sccache_prefix}/${shard_a}/${shard_b}/${shard_c}"
          run_http "201" adapter-e2e/sccache-put.txt -X PUT --data-binary @adapter-e2e/sccache.bin "http://127.0.0.1:${PORT}/${sccache_path}"
          run_http "200" adapter-e2e/sccache-head.txt -I "http://127.0.0.1:${PORT}/${sccache_path}"
          run_http "200" adapter-e2e/sccache-get.bin "http://127.0.0.1:${PORT}/${sccache_path}"
          assert_file_equals adapter-e2e/sccache.bin adapter-e2e/sccache-get.bin

          # Fail fast on known proxy failures
          declare -a BAD_PATTERNS=(
            'INTERNAL_ERROR'
            'panic'
            'thread .* panicked'
            'Validation failed on cache confirm'
            '422 Unprocessable Entity'
          )
          for pattern in "${BAD_PATTERNS[@]}"; do
            if grep -E -n "${pattern}" "${ADAPTER_PROXY_LOG}" >/tmp/adapter-pattern-hit.log 2>/dev/null; then
              echo "found bad signature pattern: ${pattern}"
              cat /tmp/adapter-pattern-hit.log
              exit 1
            fi
          done

      - name: Upload adapter E2E logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: serve-registry-adapter-e2e-logs
          path: |
            adapter-e2e/**
