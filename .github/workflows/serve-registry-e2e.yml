name: Serve Registry E2E

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

jobs:
  serve-registry-e2e:
    name: Adapter Protocol E2E (docker-buildkit)
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
      BORINGCACHE_API_URL: "https://api.boringcache.com"
      WORKSPACE: "boringcache/cli"
      E2E_TAG_PREFIX: "bc-e2e-cli"
      PORT: "5000"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust (BoringCache)
        id: boringcache-rust-registry
        continue-on-error: true
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ env.WORKSPACE }}
          rust-version: "1.89"
          cache-tag: "bc-e2e-cli-rust-docker-buildkit"
          sccache: "true"
          sccache-mode: "proxy"
          cache-target: "true"

      - name: Setup Rust (Fallback)
        if: steps.boringcache-rust-registry.outcome == 'failure'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: "1.89"

      - name: Validate configuration
        run: |
          set -euo pipefail
          if [[ -z "${BORINGCACHE_API_TOKEN:-}" ]]; then
            echo "BORINGCACHE_API_TOKEN secret is required"
            exit 1
          fi
          if [[ -z "${WORKSPACE:-}" ]]; then
            echo "WORKSPACE is not set"
            exit 1
          fi

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.x"

      - name: Build CLI
        run: cargo build --bin boringcache

      - name: Run serve edge-case unit tests
        run: |
          set -euo pipefail
          cargo test --lib serve::state::tests::find_by_digest_prefers_non_empty_finalized_session
          cargo test --lib serve::handlers::tests::put_upload_allows_local_reuse_when_finalize_payload_is_empty

      - name: Validate workspace access
        run: ./target/debug/boringcache ls "${WORKSPACE}" --limit 1

      - name: Run docker-registry edge-case e2e matrix
        run: |
          set -euo pipefail

          # Intentionally run-scoped for isolated protocol/e2e coverage.
          BUILDER="bc-e2e-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          CACHE_TAG="${E2E_TAG_PREFIX}-docker-buildkit-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          CACHE_REF="localhost:${PORT}/boringcache-e2e/cache:${CACHE_TAG}"
          CACHE_TAG_ALIAS="${CACHE_TAG}-alias"
          CACHE_REF_ALIAS="localhost:${PORT}/boringcache-e2e/cache:${CACHE_TAG_ALIAS}"
          REGISTRY_ROOT_TAG="${E2E_TAG_PREFIX}-docker-buildkit-registry-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          SERVE_PID=""
          declare -a LOG_FILES=()

          cleanup() {
            set +e
            if [[ -n "${SERVE_PID:-}" ]]; then
              kill "${SERVE_PID}" >/dev/null 2>&1 || true
              wait "${SERVE_PID}" >/dev/null 2>&1 || true
            fi
            docker buildx rm --force "${BUILDER}" >/dev/null 2>&1 || true
          }
          trap cleanup EXIT

          start_proxy() {
            local log_file="$1"
            LOG_FILES+=("$log_file")
            ./target/debug/boringcache docker-registry "${WORKSPACE}" "${REGISTRY_ROOT_TAG}" --host 127.0.0.1 --port "${PORT}" --no-platform --no-git --fail-on-cache-error > "${log_file}" 2>&1 &
            SERVE_PID=$!

            local ready=0
            for _ in $(seq 1 60); do
              if curl -fsS --max-time 1 "http://127.0.0.1:${PORT}/v2/" >/dev/null 2>&1; then
                ready=1
                break
              fi
              if ! kill -0 "${SERVE_PID}" >/dev/null 2>&1; then
                echo "boringcache docker-registry exited before readiness"
                cat "${log_file}"
                exit 1
              fi
              sleep 0.5
            done

            if [[ "${ready}" != "1" ]]; then
              echo "timed out waiting for docker-registry readiness"
              cat "${log_file}"
              exit 1
            fi
          }

          stop_proxy() {
            if [[ -n "${SERVE_PID:-}" ]]; then
              kill "${SERVE_PID}" >/dev/null 2>&1 || true
              wait "${SERVE_PID}" >/dev/null 2>&1 || true
            fi
            SERVE_PID=""
          }

          run_build() {
            local log_file="$1"
            shift
            LOG_FILES+=("$log_file")
            docker buildx build \
              --builder "${BUILDER}" \
              --progress plain \
              --load \
              --file e2e-context/Dockerfile \
              "$@" \
              e2e-context 2>&1 | tee "${log_file}"
          }

          is_transient_registry_export_error() {
            local log_file="$1"
            grep -Eq \
              'expected sha256:.*got sha256:e3b0|error writing layer blob|error writing manifest blob|unexpected status from PUT request.*(400 Bad Request|500 Internal Server Error)|Alias write failed .*confirm failed: Server error \(500\)' \
              "${log_file}"
          }

          run_build_with_retry() {
            local log_file="$1"
            shift
            local attempts=4
            local attempt
            for attempt in $(seq 1 "${attempts}"); do
              if run_build "${log_file}" "$@"; then
                return 0
              fi
              if [[ "${attempt}" -lt "${attempts}" ]] && is_transient_registry_export_error "${log_file}"; then
                echo "transient registry export error on attempt ${attempt}/${attempts}; retrying..."
                sleep $((attempt * 3))
                continue
              fi
              return 1
            done
          }

          create_builder() {
            docker buildx create \
              --name "${BUILDER}" \
              --driver docker-container \
              --driver-opt network=host \
              --use
            docker buildx inspect "${BUILDER}" --bootstrap
          }

          reset_builder() {
            docker buildx rm --force "${BUILDER}" >/dev/null 2>&1 || true
            create_builder
          }

          assert_cached() {
            local log_file="$1"
            if ! grep -q "CACHED" "${log_file}"; then
              echo "expected cached steps in ${log_file}"
              exit 1
            fi
          }

          assert_registry_import_succeeded() {
            local log_file="$1"
            if ! grep -q "importing cache manifest from" "${log_file}"; then
              echo "expected registry cache import attempt in ${log_file}"
              exit 1
            fi
            if grep -E -n "failed to configure registry cache importer|httpReadSeeker: failed open: .* not found" "${log_file}" >/tmp/e2e-import-failure.log 2>/dev/null; then
              echo "registry cache import failed in ${log_file}"
              cat /tmp/e2e-import-failure.log
              exit 1
            fi
          }

          fetch_manifest_with_retry() {
            local reference="$1"
            local manifest_file="$2"
            local attempts="${3:-20}"
            local url="http://127.0.0.1:${PORT}/v2/boringcache-e2e/cache/manifests/${reference}"
            local accept_header="Accept: application/vnd.oci.image.manifest.v1+json,application/vnd.docker.distribution.manifest.v2+json"

            for _ in $(seq 1 "${attempts}"); do
              if curl -fsS -H "${accept_header}" "${url}" -o "${manifest_file}"; then
                return 0
              fi
              sleep 1
            done

            echo "manifest did not become readable for reference ${reference} after ${attempts}s"
            return 1
          }

          resolve_manifest_digest_with_retry() {
            local reference="$1"
            local attempts="${2:-20}"
            local url="http://127.0.0.1:${PORT}/v2/boringcache-e2e/cache/manifests/${reference}"
            local accept_header="Accept: application/vnd.oci.image.manifest.v1+json,application/vnd.docker.distribution.manifest.v2+json"

            for _ in $(seq 1 "${attempts}"); do
              local digest
              digest=$(
                curl -fsS -I -H "${accept_header}" "${url}" 2>/dev/null \
                  | awk 'tolower($1)=="docker-content-digest:" {print $2}' \
                  | tr -d '\r' \
                  | tail -n1
              ) || true
              if [[ -n "${digest}" ]]; then
                echo "${digest}"
                return 0
              fi
              sleep 1
            done

            echo "manifest digest header did not become readable for reference ${reference} after ${attempts}s" >&2
            return 1
          }

          reset_builder

          mkdir -p e2e-context
          cat > e2e-context/Dockerfile <<'EOF'
          FROM scratch
          COPY payload.bin /payload.bin
          COPY f01.txt /f01.txt
          COPY f02.txt /f02.txt
          COPY f03.txt /f03.txt
          COPY f04.txt /f04.txt
          COPY f05.txt /f05.txt
          COPY f06.txt /f06.txt
          COPY f07.txt /f07.txt
          COPY f08.txt /f08.txt
          COPY f09.txt /f09.txt
          COPY f10.txt /f10.txt
          COPY f11.txt /f11.txt
          COPY f12.txt /f12.txt
          EOF
          for i in $(seq -w 1 12); do
            printf 'layer-%s\n' "${i}" > "e2e-context/f${i}.txt"
          done
          dd if=/dev/zero of=e2e-context/payload.bin bs=1M count=6 status=none

          # Phase 1: seed + warm + no-cache re-export against one tag.
          start_proxy "serve-initial.log"
          run_build_with_retry "first-build.log" \
            --cache-from "type=registry,ref=${CACHE_REF}" \
            --cache-to "type=registry,ref=${CACHE_REF},mode=max"
          reset_builder
          run_build_with_retry "second-build.log" \
            --cache-from "type=registry,ref=${CACHE_REF}" \
            --cache-to "type=registry,ref=${CACHE_REF},mode=max"
          assert_cached "second-build.log"
          assert_registry_import_succeeded "second-build.log"
          run_build_with_retry "third-build-reexport.log" \
            --no-cache \
            --cache-to "type=registry,ref=${CACHE_REF},mode=max"
          stop_proxy

          # Phase 2: restart proxy, verify cache still resolves, then alias tag finalize path.
          start_proxy "serve-restart.log"
          reset_builder
          run_build_with_retry "fourth-build-after-restart.log" \
            --cache-from "type=registry,ref=${CACHE_REF}" \
            --cache-to "type=registry,ref=${CACHE_REF},mode=max"
          assert_cached "fourth-build-after-restart.log"
          assert_registry_import_succeeded "fourth-build-after-restart.log"
          run_build_with_retry "fifth-build-alias-export.log" \
            --cache-from "type=registry,ref=${CACHE_REF}" \
            --cache-to "type=registry,ref=${CACHE_REF_ALIAS},mode=max"
          assert_registry_import_succeeded "fifth-build-alias-export.log"
          run_build_with_retry "sixth-build-alias-warm.log" \
            --cache-from "type=registry,ref=${CACHE_REF_ALIAS}" \
            --cache-to "type=registry,ref=${CACHE_REF_ALIAS},mode=max"
          assert_cached "sixth-build-alias-warm.log"
          assert_registry_import_succeeded "sixth-build-alias-warm.log"

          # Verify both tags are readable by tag and by resolved manifest digest.
          for tag in "${CACHE_TAG}" "${CACHE_TAG_ALIAS}"; do
            manifest_file="manifest-${tag}.json"
            LOG_FILES+=("${manifest_file}")
            fetch_manifest_with_retry "${tag}" "${manifest_file}"
            manifest_digest="$(resolve_manifest_digest_with_retry "${tag}")"
            digest_manifest_file="manifest-${tag}-digest.json"
            LOG_FILES+=("${digest_manifest_file}")
            fetch_manifest_with_retry "${manifest_digest}" "${digest_manifest_file}"
          done

          # Hard fail on known historical export/finalize signatures.
          declare -a BAD_PATTERNS=(
            'expected sha256:.*got sha256:e3b0'
            'error writing layer blob'
            'broken pipe'
            'Validation failed on cache confirm'
            '422 Unprocessable Entity'
            'unexpected status from PUT request.*400 Bad Request'
          )
          for pattern in "${BAD_PATTERNS[@]}"; do
            if grep -E -n "${pattern}" "${LOG_FILES[@]}" >/tmp/e2e-pattern-hit.log 2>/dev/null; then
              echo "found bad signature pattern: ${pattern}"
              cat /tmp/e2e-pattern-hit.log
              exit 1
            fi
          done

      - name: Upload E2E logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: serve-registry-e2e-logs
          path: |
            serve-initial.log
            serve-restart.log
            first-build.log
            second-build.log
            third-build-reexport.log
            fourth-build-after-restart.log
            fifth-build-alias-export.log
            sixth-build-alias-warm.log
            manifest-*.json

  serve-registry-cli-core-e2e:
    name: CLI Core E2E
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
      BORINGCACHE_API_URL: "https://api.boringcache.com"
      WORKSPACE: "boringcache/cli"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust (BoringCache)
        id: boringcache-rust-cli-core
        continue-on-error: true
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ env.WORKSPACE }}
          rust-version: "1.89"
          cache-tag: "bc-e2e-cli-rust-cli-core"
          sccache: "true"
          sccache-mode: "proxy"
          cache-target: "true"

      - name: Setup Rust (Fallback)
        if: steps.boringcache-rust-cli-core.outcome == 'failure'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: "1.89"

      - name: Validate configuration
        run: |
          set -euo pipefail
          if [[ -z "${BORINGCACHE_API_TOKEN:-}" ]]; then
            echo "BORINGCACHE_API_TOKEN secret is required"
            exit 1
          fi
          if [[ -z "${WORKSPACE:-}" ]]; then
            echo "WORKSPACE is not set"
            exit 1
          fi

      - name: Build CLI
        run: cargo build --bin boringcache

      - name: Validate workspace access
        run: ./target/debug/boringcache ls "${WORKSPACE}" --limit 1

      - name: Run CLI core command e2e
        run: |
          set -euo pipefail

          CLI="./target/debug/boringcache"
          mkdir -p cli-command-e2e
          CLI_LOG_DIR="cli-command-e2e"
          CLI_HOME="$(mktemp -d)"
          export HOME="${CLI_HOME}"

          dump_cli_debug_logs() {
            set +e
            echo "=== CLI core debug logs ==="
            if [[ -d "${CLI_LOG_DIR}" ]]; then
              shopt -s nullglob
              for log_file in "${CLI_LOG_DIR}"/*.log "${CLI_LOG_DIR}"/*.json; do
                echo "--- ${log_file} ---"
                tail -n 200 "${log_file}" || true
              done
              shopt -u nullglob
            fi
            if [[ -f "${MOUNT_LOG:-}" ]]; then
              echo "--- ${MOUNT_LOG} ---"
              tail -n 200 "${MOUNT_LOG}" || true
            fi
            echo "=== End CLI core debug logs ==="
          }
          trap dump_cli_debug_logs ERR

          AUTH_TOKEN="${BORINGCACHE_API_TOKEN}"
          "${CLI}" auth --token "${AUTH_TOKEN}" > "${CLI_LOG_DIR}/auth.log"
          unset BORINGCACHE_API_TOKEN BORINGCACHE_DEFAULT_WORKSPACE
          "${CLI}" config set default_workspace "${WORKSPACE}" > "${CLI_LOG_DIR}/config-set-workspace.log"
          "${CLI}" config set api_url "${BORINGCACHE_API_URL}" > "${CLI_LOG_DIR}/config-set-api-url.log"
          "${CLI}" config get default_workspace > "${CLI_LOG_DIR}/config-get-default-workspace.log"
          grep -q "${WORKSPACE}" "${CLI_LOG_DIR}/config-get-default-workspace.log"
          "${CLI}" config list --json > "${CLI_LOG_DIR}/config-list.json"
          "${CLI}" workspaces --json > "${CLI_LOG_DIR}/workspaces.json"
          "${CLI}" ls --limit 1 --json > "${CLI_LOG_DIR}/ls.json"

          TAG_ROOT="bc-e2e-cli-core-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          TAG_DIR="${TAG_ROOT}-dir"
          TAG_FILE="${TAG_ROOT}-file"
          TAG_MOUNT="${TAG_ROOT}-mount"
          SRC_DIR="${CLI_LOG_DIR}/src"
          RESTORE_DIR="${CLI_LOG_DIR}/restore-dir"
          SINGLE_FILE="${CLI_LOG_DIR}/single.txt"
          RESTORE_FILE_DIR="${CLI_LOG_DIR}/restore-file"
          MOUNT_SRC_DIR="${CLI_LOG_DIR}/mount-src"
          MOUNT_WATCH_DIR="${CLI_LOG_DIR}/mount-watch"
          MOUNT_RESTORE_DIR="${CLI_LOG_DIR}/mount-restore"
          MOUNT_LOG="${CLI_LOG_DIR}/mount.log"
          IDENTITY_FILE="${CLI_LOG_DIR}/age-identity.txt"
          MISSING_TAG="${TAG_ROOT}-missing"

          mkdir -p "${SRC_DIR}"
          printf 'cli-e2e-dir-%s\n' "${GITHUB_SHA}" > "${SRC_DIR}/a.txt"
          printf 'cli-e2e-nested-%s\n' "${GITHUB_RUN_ID}" > "${SRC_DIR}/nested.txt"
          printf 'cli-e2e-file-%s\n' "${GITHUB_RUN_ATTEMPT}" > "${SINGLE_FILE}"

          "${CLI}" save --no-platform --no-git "${WORKSPACE}" "${TAG_DIR}:${SRC_DIR},${TAG_FILE}:${SINGLE_FILE}" > "${CLI_LOG_DIR}/save.log"
          save_visible=0
          for _ in $(seq 1 10); do
            if "${CLI}" check --no-platform --no-git --fail-on-miss "${WORKSPACE}" "${TAG_DIR},${TAG_FILE}" > "${CLI_LOG_DIR}/check-hit.log" 2>&1; then
              save_visible=1
              break
            fi
            sleep 1
          done
          if [[ "${save_visible}" != "1" ]]; then
            echo "saved tags did not become visible in time"
            cat "${CLI_LOG_DIR}/check-hit.log"
            exit 1
          fi
          "${CLI}" restore --no-platform --no-git "${WORKSPACE}" "${TAG_DIR}:${RESTORE_DIR},${TAG_FILE}:${RESTORE_FILE_DIR}" > "${CLI_LOG_DIR}/restore.log"

          cmp -s "${SRC_DIR}/a.txt" "${RESTORE_DIR}/a.txt"
          cmp -s "${SRC_DIR}/nested.txt" "${RESTORE_DIR}/nested.txt"
          cmp -s "${SINGLE_FILE}" "${RESTORE_FILE_DIR}/single.txt"

          set +e
          "${CLI}" restore --no-platform --no-git --lookup-only --fail-on-cache-miss "${WORKSPACE}" "${MISSING_TAG}:${CLI_LOG_DIR}/missing-target" > "${CLI_LOG_DIR}/restore-miss.log" 2>&1
          restore_miss_status=$?
          set -e
          if [[ "${restore_miss_status}" -eq 0 ]]; then
            echo "expected restore miss to fail with non-zero exit code"
            cat "${CLI_LOG_DIR}/restore-miss.log"
            exit 1
          fi
          if ! grep -q "Cache miss for tags" "${CLI_LOG_DIR}/restore-miss.log"; then
            echo "restore miss log did not include cache miss summary"
            cat "${CLI_LOG_DIR}/restore-miss.log"
            exit 1
          fi

          "${CLI}" delete --no-platform --no-git "${WORKSPACE}" "${TAG_DIR},${TAG_FILE}" > "${CLI_LOG_DIR}/delete.log"
          deleted_confirmed=0
          for _ in $(seq 1 10); do
            if "${CLI}" check --no-platform --no-git --fail-on-miss "${WORKSPACE}" "${TAG_DIR},${TAG_FILE}" > "${CLI_LOG_DIR}/check-after-delete.log" 2>&1; then
              sleep 1
              continue
            fi
            deleted_confirmed=1
            break
          done
          if [[ "${deleted_confirmed}" != "1" ]]; then
            echo "deleted tags were still visible after retries"
            cat "${CLI_LOG_DIR}/check-after-delete.log"
            exit 1
          fi

          RUN_TAG="${TAG_ROOT}-run"
          RUN_PROXY_TAG="${TAG_ROOT}-run-proxy"
          RUN_SEED_DIR="${CLI_LOG_DIR}/run-seed"
          RUN_TARGET_DIR="${CLI_LOG_DIR}/run-target"
          RUN_VERIFY_DIR="${CLI_LOG_DIR}/run-verify"
          RUN_MISS_SENTINEL="${CLI_LOG_DIR}/run-miss-sentinel.txt"

          mkdir -p "${RUN_SEED_DIR}"
          printf 'run-warm-cache-%s\n' "${GITHUB_SHA}" > "${RUN_SEED_DIR}/restored.txt"
          "${CLI}" save --no-platform --no-git "${WORKSPACE}" "${RUN_TAG}:${RUN_SEED_DIR}" > "${CLI_LOG_DIR}/run-seed-save.log"

          run_seed_visible=0
          for _ in $(seq 1 10); do
            if "${CLI}" check --no-platform --no-git --fail-on-miss "${WORKSPACE}" "${RUN_TAG}" > "${CLI_LOG_DIR}/run-seed-check.log" 2>&1; then
              run_seed_visible=1
              break
            fi
            sleep 1
          done
          if [[ "${run_seed_visible}" != "1" ]]; then
            echo "run seed tag did not become visible in time"
            cat "${CLI_LOG_DIR}/run-seed-check.log"
            exit 1
          fi

          run_archive_script=$'[ "$(cat "$1/restored.txt")" = "run-warm-cache-'"${GITHUB_SHA}"'" ] || exit 27\nprintf "run-generated-%s\\n" "'"${GITHUB_RUN_ID}"'" > "$1/generated.txt"'
          "${CLI}" run --no-platform --no-git --fail-on-cache-error "${WORKSPACE}" "${RUN_TAG}:${RUN_TARGET_DIR}" -- sh -ec "${run_archive_script}" _ "${RUN_TARGET_DIR}" > "${CLI_LOG_DIR}/run-archive.log"

          "${CLI}" restore --no-platform --no-git "${WORKSPACE}" "${RUN_TAG}:${RUN_VERIFY_DIR}" > "${CLI_LOG_DIR}/run-verify-restore.log"
          grep -q "run-generated-${GITHUB_RUN_ID}" "${RUN_VERIFY_DIR}/generated.txt"

          set +e
          "${CLI}" run --no-platform --no-git --fail-on-cache-miss "${WORKSPACE}" "${MISSING_TAG}:${CLI_LOG_DIR}/run-missing-target" -- sh -ec 'printf "unexpected-run\n" > "$1"' _ "${RUN_MISS_SENTINEL}" > "${CLI_LOG_DIR}/run-miss.log" 2>&1
          run_miss_status=$?
          set -e
          if [[ "${run_miss_status}" -ne 78 ]]; then
            echo "expected run miss exit code 78, got ${run_miss_status}"
            cat "${CLI_LOG_DIR}/run-miss.log"
            exit 1
          fi
          if [[ -f "${RUN_MISS_SENTINEL}" ]]; then
            echo "run child command executed despite fail-on-cache-miss"
            cat "${CLI_LOG_DIR}/run-miss.log"
            exit 1
          fi

          run_proxy_script=$'endpoint="${NX_SELF_HOSTED_REMOTE_CACHE_SERVER:-}"\n[ -n "${endpoint}" ] || exit 31\n[ "${TURBO_API:-}" = "${endpoint}" ] || exit 32\nexpected_ref="127.0.0.1:$1/cache:$2"\n[ "$3" = "${expected_ref}" ] || exit 33\ncurl -fsS --max-time 2 "${endpoint}/v2/" >/dev/null || exit 34'
          "${CLI}" run "${WORKSPACE}" --proxy "${RUN_PROXY_TAG}" --no-platform --no-git --host 127.0.0.1 --port 0 -- sh -ec "${run_proxy_script}" _ "{PORT}" "${RUN_PROXY_TAG}" "{CACHE_REF}" > "${CLI_LOG_DIR}/run-proxy.log"

          "${CLI}" delete --no-platform --no-git "${WORKSPACE}" "${RUN_TAG}" > "${CLI_LOG_DIR}/run-delete.log"

          "${CLI}" setup-encryption "${WORKSPACE}" --identity-output "${IDENTITY_FILE}" > "${CLI_LOG_DIR}/setup-encryption.log"
          if [[ ! -f "${IDENTITY_FILE}" ]]; then
            echo "setup-encryption did not create identity file"
            exit 1
          fi
          if [[ "$(stat -c '%a' "${IDENTITY_FILE}")" != "600" ]]; then
            echo "identity file permissions are not 0600"
            stat -c '%a %n' "${IDENTITY_FILE}"
            exit 1
          fi

          mkdir -p "${MOUNT_SRC_DIR}"
          printf 'mount-initial-%s\n' "${GITHUB_SHA}" > "${MOUNT_SRC_DIR}/file.txt"
          "${CLI}" save --no-platform --no-git "${WORKSPACE}" "${TAG_MOUNT}:${MOUNT_SRC_DIR}" > "${CLI_LOG_DIR}/mount-save.log"

          "${CLI}" ls "${WORKSPACE}" --limit 50 --json > "${CLI_LOG_DIR}/ls-after-encryption.json"
          if ! jq -e --arg tag "${TAG_MOUNT}" '.entries[]? | select(.tag == $tag and .encrypted == true)' "${CLI_LOG_DIR}/ls-after-encryption.json" >/dev/null; then
            echo "encrypted entry for ${TAG_MOUNT} was not visible in ls output"
            cat "${CLI_LOG_DIR}/ls-after-encryption.json"
            exit 1
          fi

          MOUNT_PID=""
          cleanup_mount() {
            set +e
            if [[ -n "${MOUNT_PID:-}" ]] && kill -0 "${MOUNT_PID}" >/dev/null 2>&1; then
              kill -INT "${MOUNT_PID}" >/dev/null 2>&1 || true
              wait "${MOUNT_PID}" >/dev/null 2>&1 || true
            fi
          }
          trap cleanup_mount EXIT

          "${CLI}" mount "${WORKSPACE}" "${TAG_MOUNT}:${MOUNT_WATCH_DIR}" --identity "${IDENTITY_FILE}" --verbose > "${MOUNT_LOG}" 2>&1 &
          MOUNT_PID=$!

          mount_ready=0
          for _ in $(seq 1 30); do
            if ! kill -0 "${MOUNT_PID}" >/dev/null 2>&1; then
              echo "mount exited before readiness"
              cat "${MOUNT_LOG}"
              exit 1
            fi
            if grep -q "Watching" "${MOUNT_LOG}"; then
              mount_ready=1
              break
            fi
            sleep 1
          done
          if [[ "${mount_ready}" != "1" ]]; then
            echo "mount did not reach watch state in time"
            cat "${MOUNT_LOG}"
            exit 1
          fi

          printf 'mount-updated-%s\n' "${GITHUB_RUN_ID}" >> "${MOUNT_WATCH_DIR}/file.txt"
          sleep 2
          kill -INT "${MOUNT_PID}" >/dev/null 2>&1 || true
          if ! wait "${MOUNT_PID}"; then
            echo "mount exited with non-zero status"
            cat "${MOUNT_LOG}"
            exit 1
          fi
          if grep -q "Final sync failed" "${MOUNT_LOG}"; then
            echo "mount reported final sync failure"
            cat "${MOUNT_LOG}"
            exit 1
          fi
          MOUNT_PID=""
          trap - EXIT

          "${CLI}" restore --no-platform --no-git --identity "${IDENTITY_FILE}" "${WORKSPACE}" "${TAG_MOUNT}:${MOUNT_RESTORE_DIR}" > "${CLI_LOG_DIR}/mount-restore.log"
          grep -q "mount-updated-${GITHUB_RUN_ID}" "${MOUNT_RESTORE_DIR}/file.txt"

          "${CLI}" delete --no-platform --no-git "${WORKSPACE}" "${TAG_MOUNT}" > "${CLI_LOG_DIR}/mount-delete.log"

      - name: Upload CLI core E2E logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: serve-registry-cli-core-e2e-logs
          path: |
            cli-command-e2e/**

  serve-registry-adapter-e2e:
    name: Adapter Protocol E2E (${{ matrix.suite }})
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        suite: [bazel, gradle, nx, turbo, sccache, go]
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
      BORINGCACHE_API_URL: "https://api.boringcache.com"
      WORKSPACE: "boringcache/cli"
      E2E_TAG_PREFIX: "bc-e2e-cli"
      PORT: "5001"
      SUITE: ${{ matrix.suite }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust (BoringCache)
        id: boringcache-rust-adapter
        continue-on-error: true
        uses: boringcache/rust-action@v1
        with:
          workspace: ${{ env.WORKSPACE }}
          rust-version: "1.89"
          cache-tag: "bc-e2e-cli-rust-adapter-${{ matrix.suite }}"
          sccache: "true"
          sccache-mode: "proxy"
          cache-target: "true"

      - name: Setup Rust (Fallback)
        if: steps.boringcache-rust-adapter.outcome == 'failure'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: "1.89"

      - name: Validate configuration
        run: |
          set -euo pipefail
          if [[ -z "${BORINGCACHE_API_TOKEN:-}" ]]; then
            echo "BORINGCACHE_API_TOKEN secret is required"
            exit 1
          fi
          if [[ -z "${WORKSPACE:-}" ]]; then
            echo "WORKSPACE is not set"
            exit 1
          fi

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.x"

      - name: Build CLI
        run: cargo build --bin boringcache

      - name: Validate workspace access
        run: ./target/debug/boringcache ls "${WORKSPACE}" --limit 1

      - name: Run adapter protocol suite e2e
        run: |
          set -euo pipefail

          mkdir -p adapter-e2e
          REGISTRY_ROOT_TAG="${E2E_TAG_PREFIX}-adapter-${SUITE}-registry-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          SERVE_PID=""
          ADAPTER_PROXY_LOG="adapter-e2e/adapter-proxy-${SUITE}.log"

          dump_adapter_debug_logs() {
            set +e
            echo "=== Adapter debug logs (${SUITE}) ==="
            if [[ -f "${ADAPTER_PROXY_LOG}" ]]; then
              echo "--- ${ADAPTER_PROXY_LOG} ---"
              tail -n 200 "${ADAPTER_PROXY_LOG}" || true
            fi
            if [[ -d adapter-e2e ]]; then
              shopt -s nullglob
              for log_file in adapter-e2e/*.log adapter-e2e/*.txt adapter-e2e/*.json; do
                echo "--- ${log_file} ---"
                tail -n 200 "${log_file}" || true
              done
              shopt -u nullglob
            fi
            echo "=== End adapter debug logs (${SUITE}) ==="
          }
          trap dump_adapter_debug_logs ERR

          cleanup() {
            set +e
            if [[ -n "${SERVE_PID:-}" ]]; then
              kill "${SERVE_PID}" >/dev/null 2>&1 || true
              wait "${SERVE_PID}" >/dev/null 2>&1 || true
            fi
          }
          trap cleanup EXIT

          start_proxy() {
            ./target/debug/boringcache docker-registry "${WORKSPACE}" "${REGISTRY_ROOT_TAG}" --host 127.0.0.1 --port "${PORT}" --no-platform --no-git --fail-on-cache-error > "${ADAPTER_PROXY_LOG}" 2>&1 &
            SERVE_PID=$!

            local ready=0
            for _ in $(seq 1 60); do
              if curl -fsS --max-time 1 "http://127.0.0.1:${PORT}/v2/" >/dev/null 2>&1; then
                ready=1
                break
              fi
              if ! kill -0 "${SERVE_PID}" >/dev/null 2>&1; then
                echo "boringcache docker-registry exited before readiness"
                cat "${ADAPTER_PROXY_LOG}"
                exit 1
              fi
              sleep 0.5
            done

            if [[ "${ready}" != "1" ]]; then
              echo "timed out waiting for docker-registry readiness"
              cat "${ADAPTER_PROXY_LOG}"
              exit 1
            fi
          }

          run_http() {
            local expected_status="$1"
            local output_path="$2"
            shift 2
            local status
            status=$(curl -sS -o "${output_path}" -w "%{http_code}" "$@")
            if [[ "${status}" != "${expected_status}" ]]; then
              echo "unexpected status: expected ${expected_status}, got ${status}"
              echo "curl args: $*"
              if [[ -f "${output_path}" ]]; then
                cat "${output_path}"
              fi
              exit 1
            fi
          }

          assert_file_equals() {
            local expected="$1"
            local actual="$2"
            if ! cmp -s "${expected}" "${actual}"; then
              echo "payload mismatch between ${expected} and ${actual}"
              exit 1
            fi
          }

          start_proxy

          case "${SUITE}" in
            bazel)
              bazel_key=$(printf 'bazel-%s-%s-%s' "${GITHUB_RUN_ID}" "${GITHUB_RUN_ATTEMPT}" "${GITHUB_SHA}" | sha256sum | awk '{print $1}')
              printf 'bazel-e2e-%s\n' "${bazel_key}" > adapter-e2e/bazel.bin
              run_http "200" adapter-e2e/bazel-cas-put.txt -X PUT --data-binary @adapter-e2e/bazel.bin "http://127.0.0.1:${PORT}/cas/${bazel_key}"
              run_http "200" adapter-e2e/bazel-cas-head.txt -I "http://127.0.0.1:${PORT}/cas/${bazel_key}"
              run_http "200" adapter-e2e/bazel-cas-get.bin "http://127.0.0.1:${PORT}/cas/${bazel_key}"
              assert_file_equals adapter-e2e/bazel.bin adapter-e2e/bazel-cas-get.bin

              run_http "200" adapter-e2e/bazel-ac-put.txt -X PUT --data-binary @adapter-e2e/bazel.bin "http://127.0.0.1:${PORT}/ac/${bazel_key}"
              run_http "200" adapter-e2e/bazel-ac-get.bin "http://127.0.0.1:${PORT}/ac/${bazel_key}"
              assert_file_equals adapter-e2e/bazel.bin adapter-e2e/bazel-ac-get.bin
              ;;
            gradle)
              gradle_key="gradle-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${GITHUB_SHA:0:7}"
              printf 'gradle-e2e-%s\n' "${gradle_key}" > adapter-e2e/gradle.bin
              run_http "200" adapter-e2e/gradle-put.txt -X PUT --data-binary @adapter-e2e/gradle.bin "http://127.0.0.1:${PORT}/cache/${gradle_key}"
              run_http "200" adapter-e2e/gradle-head.txt -I "http://127.0.0.1:${PORT}/cache/${gradle_key}"
              run_http "200" adapter-e2e/gradle-get.bin "http://127.0.0.1:${PORT}/cache/${gradle_key}"
              assert_file_equals adapter-e2e/gradle.bin adapter-e2e/gradle-get.bin
              ;;
            nx)
              nx_hash=$(printf 'nx-%s-%s-%s' "${GITHUB_RUN_ID}" "${GITHUB_RUN_ATTEMPT}" "${GITHUB_SHA}" | sha256sum | awk '{print $1}')
              nx_auth="authorization: Bearer nx-token-${GITHUB_RUN_ID}"
              printf 'nx-e2e-%s\n' "${nx_hash}" > adapter-e2e/nx.bin
              run_http "200" adapter-e2e/nx-put.txt -X PUT -H "${nx_auth}" --data-binary @adapter-e2e/nx.bin "http://127.0.0.1:${PORT}/v1/cache/${nx_hash}"
              run_http "200" adapter-e2e/nx-head.txt -I -H "${nx_auth}" "http://127.0.0.1:${PORT}/v1/cache/${nx_hash}"
              run_http "200" adapter-e2e/nx-get.bin -H "${nx_auth}" "http://127.0.0.1:${PORT}/v1/cache/${nx_hash}"
              assert_file_equals adapter-e2e/nx.bin adapter-e2e/nx-get.bin

              printf 'nx-terminal-output-%s\n' "${nx_hash}" > adapter-e2e/nx-terminal.txt
              run_http "200" adapter-e2e/nx-terminal-put.txt -X PUT -H "${nx_auth}" --data-binary @adapter-e2e/nx-terminal.txt "http://127.0.0.1:${PORT}/v1/cache/${nx_hash}/terminalOutputs"
              run_http "200" adapter-e2e/nx-terminal-get.txt -H "${nx_auth}" "http://127.0.0.1:${PORT}/v1/cache/${nx_hash}/terminalOutputs"
              assert_file_equals adapter-e2e/nx-terminal.txt adapter-e2e/nx-terminal-get.txt

              printf '{"hashes":["%s","deadbeef"]}\n' "${nx_hash}" > adapter-e2e/nx-query.json
              run_http "200" adapter-e2e/nx-query-response.json -X POST -H "${nx_auth}" -H "content-type: application/json" --data @adapter-e2e/nx-query.json "http://127.0.0.1:${PORT}/v1/cache"
              grep -q '"misses"' adapter-e2e/nx-query-response.json
              grep -q 'deadbeef' adapter-e2e/nx-query-response.json
              ;;
            turbo)
              turbo_hash=$(printf 'turbo-%s-%s-%s' "${GITHUB_RUN_ID}" "${GITHUB_RUN_ATTEMPT}" "${GITHUB_SHA}" | sha256sum | awk '{print $1}')
              turbo_auth="authorization: Bearer turbo-token-${GITHUB_RUN_ID}"
              printf 'turbo-e2e-%s\n' "${turbo_hash}" > adapter-e2e/turbo.bin

              run_http "200" adapter-e2e/turbo-status.json -H "${turbo_auth}" "http://127.0.0.1:${PORT}/v8/artifacts/status"
              grep -q '"status":"enabled"' adapter-e2e/turbo-status.json
              run_http "202" adapter-e2e/turbo-put.json -X PUT -H "${turbo_auth}" --data-binary @adapter-e2e/turbo.bin "http://127.0.0.1:${PORT}/v8/artifacts/${turbo_hash}"
              grep -q '"urls"' adapter-e2e/turbo-put.json
              run_http "200" adapter-e2e/turbo-head.txt -I -H "${turbo_auth}" "http://127.0.0.1:${PORT}/v8/artifacts/${turbo_hash}"
              run_http "200" adapter-e2e/turbo-get.bin -H "${turbo_auth}" "http://127.0.0.1:${PORT}/v8/artifacts/${turbo_hash}"
              assert_file_equals adapter-e2e/turbo.bin adapter-e2e/turbo-get.bin

              printf '{"hashes":["%s","deadbeef"]}\n' "${turbo_hash}" > adapter-e2e/turbo-query.json
              run_http "200" adapter-e2e/turbo-query-response.json -X POST -H "${turbo_auth}" -H "content-type: application/json" --data @adapter-e2e/turbo-query.json "http://127.0.0.1:${PORT}/v8/artifacts"
              grep -q "\"${turbo_hash}\"" adapter-e2e/turbo-query-response.json
              grep -q '"size"' adapter-e2e/turbo-query-response.json

              printf '[{"sessionId":"e2e","source":"REMOTE","event":"HIT","hash":"%s","duration":7}]\n' "${turbo_hash}" > adapter-e2e/turbo-events.json
              run_http "200" adapter-e2e/turbo-events-response.txt -X POST -H "${turbo_auth}" -H "content-type: application/json" --data @adapter-e2e/turbo-events.json "http://127.0.0.1:${PORT}/v8/artifacts/events"
              ;;
            sccache)
              sccache_key=$(printf 'sccache-%s-%s-%s' "${GITHUB_RUN_ID}" "${GITHUB_RUN_ATTEMPT}" "${GITHUB_SHA}" | sha256sum | awk '{print $1}')
              shard_a="${sccache_key:0:1}"
              shard_b="${sccache_key:1:1}"
              shard_c="${sccache_key:2:1}"
              sccache_prefix="sccache-e2e-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
              sccache_path="${sccache_prefix}/${shard_a}/${shard_b}/${shard_c}/${sccache_key}"
              printf 'sccache-e2e-%s\n' "${sccache_key}" > adapter-e2e/sccache.bin

              run_http "201" adapter-e2e/sccache-mkcol.txt -X MKCOL "http://127.0.0.1:${PORT}/${sccache_prefix}/${shard_a}/${shard_b}/${shard_c}"
              run_http "201" adapter-e2e/sccache-put.txt -X PUT --data-binary @adapter-e2e/sccache.bin "http://127.0.0.1:${PORT}/${sccache_path}"
              run_http "200" adapter-e2e/sccache-head.txt -I "http://127.0.0.1:${PORT}/${sccache_path}"
              run_http "200" adapter-e2e/sccache-get.bin "http://127.0.0.1:${PORT}/${sccache_path}"
              assert_file_equals adapter-e2e/sccache.bin adapter-e2e/sccache-get.bin
              ;;
            go)
              go_action=$(printf 'go-action-%s-%s-%s' "${GITHUB_RUN_ID}" "${GITHUB_RUN_ATTEMPT}" "${GITHUB_SHA}" | sha256sum | awk '{print $1}')
              printf 'go-e2e-%s\n' "${go_action}" > adapter-e2e/go.bin
              run_http "201" adapter-e2e/go-put.txt -X PUT --data-binary @adapter-e2e/go.bin "http://127.0.0.1:${PORT}/gocache/${go_action}"
              run_http "200" adapter-e2e/go-head.txt -I "http://127.0.0.1:${PORT}/gocache/${go_action}"
              run_http "200" adapter-e2e/go-get.bin "http://127.0.0.1:${PORT}/gocache/${go_action}"
              assert_file_equals adapter-e2e/go.bin adapter-e2e/go-get.bin

              mkdir -p adapter-e2e/go-prog
              printf 'module example.com/boringcache-go-prog\n\ngo 1.25\n' > adapter-e2e/go-prog/go.mod
              printf 'package main\n\nimport "fmt"\n\nfunc main() {\n  fmt.Println("boringcache-go-e2e")\n}\n' > adapter-e2e/go-prog/main.go
              CLI_BIN="${GITHUB_WORKSPACE}/target/debug/boringcache"
              GOCACHEPROG_CMD="${CLI_BIN} go-cacheprog --endpoint http://127.0.0.1:${PORT} --verbose"
              (
                cd adapter-e2e/go-prog
                GOCACHE="$(mktemp -d)" GOCACHEPROG="${GOCACHEPROG_CMD}" go build ./... 2> ../go-build-1.log
              )
              (
                cd adapter-e2e/go-prog
                GOCACHE="$(mktemp -d)" GOCACHEPROG="${GOCACHEPROG_CMD}" go build ./... 2> ../go-build-2.log
              )
              tail -n 80 adapter-e2e/go-build-1.log
              tail -n 80 adapter-e2e/go-build-2.log
              grep -q 'go-cacheprog put ok' adapter-e2e/go-build-1.log
              grep -q 'go-cacheprog get hit' adapter-e2e/go-build-2.log
              ;;
            *)
              echo "unknown suite: ${SUITE}"
              exit 1
              ;;
          esac

          declare -a BAD_PATTERNS=(
            'INTERNAL_ERROR'
            'panic'
            'thread .* panicked'
            'Validation failed on cache confirm'
            '422 Unprocessable Entity'
          )
          for pattern in "${BAD_PATTERNS[@]}"; do
            if grep -E -n "${pattern}" "${ADAPTER_PROXY_LOG}" >/tmp/adapter-pattern-hit.log 2>/dev/null; then
              echo "found bad signature pattern: ${pattern}"
              cat /tmp/adapter-pattern-hit.log
              exit 1
            fi
          done

      - name: Upload adapter E2E logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: serve-registry-adapter-e2e-logs-${{ matrix.suite }}
          path: |
            adapter-e2e/**
